<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta charset="UTF-8" />
<title>CocoDoc Design Doc</title>
</head><body>
<h1>CocoDoc Design Doc v1</h1>
<aside>Date: <time>2015-04-23</time>.</aside>
<section>
   <h2>Purpose</h2>
   <p>
      CocoDoc is a simple file processor specialise in merging text and binary files to build independent, single file web app.
      (It is <em>not</em> designed to replace Ant/Grunt/Gulp.)
   </p>
   <h3>Aims</h3>
   <ol>
      <li>Simple setup, simple to build. (e.g. drop file on builder / default build file)</li>
      <li>Base (x)html file can be used both after build (single file) and before build (multi-file).</li>
      <li>Multi-level building. (e.g. consolidate data js and trim/compress as one entity)</li>
      <li>Support data uri, mime detection, charset conversion.</li>
      <li>Support both GUI and commandline (headless) environment.</li>
   </ol>
</section>
<section>
   <h2>Program</h2>
   <p>
      CocoDoc is written in Java SE 1.8 and deployed in form of an executable, independent jar file.
      GUI is done in Java FX.
   </p>
   <p>
      All libraries (if any), licenses and documentations are included in the jar.
      Licenses and user manual are accessible through command line arguments or GUI.
   </p>
   <h3>Program Structure</h3>
   <dl>
      <dt>sheepy.cocodoc</dt><dd>Base package. Main application entry point.</dd>
      <dt>sheepy.cocodoc.ui</dt><dd>User Interface package.</dd>
      <dt>sheepy.cocodoc.worker</dt><dd>Main processing logic package.</dd>
      <dt>sheepy.cocodoc.worker.directive</dt><dd>Processing directive. Represents major, structural CocoDoc commands, argumented by tasks.</dd>
      <dt>sheepy.cocodoc.worker.error</dt><dd>Application specific exceptions. Most runtime errors are wrapped in these.</dd>
      <dt>sheepy.cocodoc.worker.parser</dt><dd>Parser package.  Parsers parse Coco tags, Html Tag, or trim JavaScript.</dd>
      <dt>sheepy.cocodoc.worker.task</dt><dd>Task package. A task modifies or parses data, such as converting to base64.</dd>
      <dt>sheepy.cocodoc.worker.util</dt><dd>App specific utilities / helper classes.</dd>
      <dt>sheepy.util</dt><dd>Generic utilities / helper classes.</dd>
   </dl>

   <h3>Process Flow</h3>
   <ol>
   <li>A job is initialised by selecting a file, through command line or GUI.</li>
   <li>A new <code>INLINE</code> <code>Directive</code> is created to read the file and do coco parsing.</li>
   <li>A directive do one of these things when ran (<code>Directive.start</code>):
      <ul>
      <li> <code>DirInline</code> creates a new, empty <code>Block</code>, and calls <code>Worker</code> to run it. </li>
      <li> <code>DirStart</code> create a new <code>Block</code> populated with directive content.
           A clone of parent's parser will <code>start()</code> on the block.
           When done, <code>Worker</code> is called to run the block. </li>
      <li> <code>DirOutput</code> will immediately run all its tasks, which should set the output target of containing block. </li>
      <li> <code>DirEnd</code> is handled by CocoParser. </li>
      </ul>
      Worker runs a <code>Block</code> in a new Thread. <br/>
      Thus for <code>INLINE</code> and <code>START</code>, trying to get result will block until the thread finish. <br/>
      <code>OUTPUT</code> and <code>END</code> directives does not create new thread and would returns immediately.
   </li>
   <li> Each <code>INLINE</code> and <code>START</code> has a <code>Block</code>.  When a block runs it will:
      <ol>
      <li> Initiate each <code>Task</code> of the directive, which currently just validate parameters. </li>
      <li> Execute each <code>Task</code> one by one. </li>
      <li> If the block has an output target, the block will saves its content into the output and becomes empty. </li>
      <li> Otherwise, the content can be retrieved by the parent block.  If there are not parent block they goes to <code>system.out</code>. </li>
      </ol>
   </li>
   <li> Different <code>Task</code> do different things:
      <ol>
      <li> <code>TaskFile</code> (of <code>INLINE Directive</code>) reads file(s) and adds to the block's content. </li>
      <li> <code>TaskFile</code> (of <code>OUTPUT Directive</code>) set the block's output target. </li>
      <li> <code>TaskDelete</code> does nothing and will be executed by <code>ParserCoco</code>. </li>
      <li> <code>TaskPosition</code> does nothing and will be executed by <code>ParserCoco</code>. </li>
      <li> <code>TaskCoco</code> calls <code>ParserCoco.parse</code> to parse <code>Directive</code>s. It does two things:
         <ol>
         <li> <code>start()</code> will parse the document structure:
            <ol>
            <li> Calls <code>parseDirective</code> (which calls <code>parseTask</code>) to find and parse next coco directive. </li>
            <li> <code>DirStart</code> will cause parser to transfer unparsed text to it and run it (until it meets <code>DirEnd</code>).
                 Then this parsing continues with the (updated) directive text. </li>
            <li> <code>DirEnd</code> immediately stop the parsing, and remaining (unparsed) text to be transferred to the parent <code>DirStart</code>. </li>
            <li> Other directives are ran. </li>
            <li> All directives are added to a list of Directives. (except <code>DirEnd</code>) </li>
            <li> Non-directive text are concatenated to form the foundation of result text. </li>
            </ol>
         </li>
         <li> <code>get()</code> will process each parsed <code>Directive</code> to compose the actual result.
            <ol>
            <li> (Result text is parsed as loose XML when necessary, with the first delete or position task.) </li>
            <li> Each <code>delete</code> task parameter is parsed by <code>parseSelector</code> which yields <code>XmlSelector</code>. <br/>
                 <code>locate</code> is called on the selector to get the <code>TextRange</code>, and then deleted from the result. </li>
            <li> If the <code>Directive</code> has no data, process will skip to next directive. </li>
            <li> The last <code>position</code> parameter is also parsed by <code>parseSelector</code> and located. </li>
            <li> If the location is an attribute, it is changed to attribute value instead. </li>
            <li> The location is deleted, and the result inserted to the position. </li>
            </ol>
         </li>
         </ol>
      </li>
      <li>Other tasks modify or otherwise work with current block data.</li>
      </ol>
   </li>
   </ol>

</section>
</body></html>